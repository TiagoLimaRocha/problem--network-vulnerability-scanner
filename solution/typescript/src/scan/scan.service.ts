import { NotFoundException } from "../exception/not-found.exception";
import { AssetTypeEnum, ScanResult, ScanResultsSummary, VulnerabilitySeverityEnum } from "../scan/scan.types";

import { mockData } from "../utils/mockData";
const data = mockData();

export class ScanService {
  private results: Map<string, ScanResult[]>;

  constructor() {
    this.results = new Map<string, ScanResult[]>();
  }

  public scan(assetType: AssetTypeEnum): Promise<ScanResult> {
    return new Promise<ScanResult>((resolve, reject) => {
      switch (assetType) {
        case AssetTypeEnum.Network:
          resolve(this.scanNetwork('network'));
          break;
        case AssetTypeEnum.Server:
          resolve(this.scanServer('server'));
          break;
        case AssetTypeEnum.Workstation:
          resolve(this.scanWorkstation('workstation'));
          break;
        default:
          reject(new NotFoundException(`Invalid asset type: ${assetType}`));
          break;
      }
    });
  }

  public processScanResults(date: Date) {
    return new Promise<ScanResultsSummary>(async (resolve) => {
      console.log(`Processing scan results for ${date.toISOString()}...`);

      const resultsExistsForDate = this.results.has(this.getKeyFromDate(date));
      if (resultsExistsForDate) {
        const results = this.results.get(this.getKeyFromDate(date))!;

        const lowVulnerabilities = [];
        const mediumVulnerabilities = [];
        const highVulnerabilities = [];
        const criticalVulnerabilities = [];

        for (const result of results) {
          for (const vulnerability of result.vulnerabilities) {
            switch (vulnerability.severity) {
              case VulnerabilitySeverityEnum.Low:
                lowVulnerabilities.push(vulnerability);
                break;
              case VulnerabilitySeverityEnum.Medium:
                mediumVulnerabilities.push(vulnerability);
                break;
              case VulnerabilitySeverityEnum.High:
                highVulnerabilities.push(vulnerability);
                break;
              case VulnerabilitySeverityEnum.Critical:
                criticalVulnerabilities.push(vulnerability);
                break;
              default:
                break;
            }
          }
        }

        const promises = [
          this.calcVulnerabilityCount(results),
          this.calcVulnerabilityCount(results.filter(({ assetType }) => assetType === AssetTypeEnum.Server)),
          this.calcVulnerabilityCount(results.filter(({ assetType }) => assetType === AssetTypeEnum.Network)),
          this.calcVulnerabilityCount(results.filter(({ assetType }) => assetType === AssetTypeEnum.Workstation)),
        ];

        const [
          totalVulnerabilities,
          totalServerVulnerabilities,
          totalNetworkVulnerabilities,
          totalWorkstationVulnerabilities,
        ] = await Promise.all(promises);

        const summary: ScanResultsSummary = {
          totalVulnerabilities,
          totalServerVulnerabilities,
          totalWorkstationVulnerabilities,
          totalNetworkVulnerabilities,
          totalLow: lowVulnerabilities.length,
          totalMedium: mediumVulnerabilities.length,
          totalHigh: highVulnerabilities.length,
          totalCritical: criticalVulnerabilities.length,
        };

        resolve(summary);
      }
    });
  }

  private async scanServer(name: string) {
    console.log(`Scannign server: ${name}...`);
    this.setResults(data.server);

    return data.server;
  }

  private async scanWorkstation(name: string) {
    console.log(`Scanning workstation: ${name}...`)
    this.setResults(data.workstation);

    return data.workstation;
  }

  private async scanNetwork(name: string) {
    console.log(`Scanning network: ${name}...`);
    this.setResults(data.network);

    return data.network;
  }

  private setResults(data: any) {
    const date = new Date();
    const key = this.getKeyFromDate(date);

    if (this.results.has(key)) {
      const existingResults = this.results.get(key)!;
      this.results.set(key, [...existingResults, data]);
    } else {
      this.results.set(key, [data]);
    }
  }

  private getKeyFromDate(date: Date): string {
    return date.toISOString().match(/(\d{4}-\d{2}-\d{2})/g)!.pop() as string;
  }

  private async calcVulnerabilityCount(results: ScanResult[]): Promise<number> {
    return results.reduce((acc, { vulnerabilities }) => acc + vulnerabilities.length, 0)
  }
}